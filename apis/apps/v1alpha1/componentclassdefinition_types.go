/*
Copyright (C) 2022-2023 ApeCloud Co., Ltd

This file is part of KubeBlocks project

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package v1alpha1

import (
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// ComponentClassDefinitionSpec defines the desired state of ComponentClassDefinition
type ComponentClassDefinitionSpec struct {
	// group defines a list of class series that conform to the same constraint.
	// +optional
	Groups []ComponentClassGroup `json:"groups,omitempty"`
}

type ComponentClassGroup struct {
	// resourceConstraintRef reference to the resource constraint object name, indicates that the series
	// defined below all conform to the constraint.
	// +kubebuilder:validation:Required
	ResourceConstraintRef string `json:"resourceConstraintRef"`

	// template is a class definition template that uses the Go template syntax and allows for variable declaration.
	// When defining a class in Series, specifying the variable's value is sufficient, as the complete class
	// definition will be generated through rendering the template.
	//
	// For example:
	//	template: |
	//	  cpu: "{{ or .cpu 1 }}"
	//	  memory: "{{ or .memory 4 }}Gi"
	//	  storage:
	//	  - name: data
	//	    size: "{{ or .dataStorageSize 10 }}Gi"
	//	  - name: log
	//	    size: "{{ or .logStorageSize 1 }}Gi"
	//
	// +optional
	Template string `json:"template,omitempty"`

	// vars defines the variables declared in the template and will be used to generating the complete class definition by
	// render the template.
	// +listType=set
	// +optional
	Vars []string `json:"vars,omitempty"`

	// series is a series of class definitions.
	// +optional
	Series []ComponentClassSeries `json:"series,omitempty"`
}

type ComponentClassSeries struct {
	// namingTemplate is a template that uses the Go template syntax and allows for referencing variables defined
	// in ComponentClassGroup.Template. This enables dynamic generation of class names.
	// For example:
	// name: "general-{{ .cpu }}c{{ .memory }}g"
	// +optional
	NamingTemplate string `json:"namingTemplate,omitempty"`

	// classes are definitions of classes that come in two forms. In the first form, only ComponentClass.Args
	// need to be defined, and the complete class definition is generated by rendering the ComponentClassGroup.Template
	// and Name. In the second form, the Name, CPU, Memory, and Volumes must be defined.
	// +optional
	Classes []ComponentClass `json:"classes,omitempty"`
}

type ComponentClass struct {
	// name is the class name
	// +optional
	Name string `json:"name,omitempty"`

	// args are variable's value
	// +optional
	Args []string `json:"args,omitempty"`

	// the CPU of the class
	// +optional
	CPU resource.Quantity `json:"cpu,omitempty"`

	// the memory of the class
	// +optional
	Memory resource.Quantity `json:"memory,omitempty"`

	// the volumes of the class
	// +listType=map
	// +listMapKey=name
	// +optional
	Volumes []Volume `json:"volumes,omitempty"`

	// the variants of the class in different clouds.
	// +listType=map
	// +listMapKey=provider
	// +optional
	Variants []ProviderComponentClassDef `json:"variants,omitempty"`
}

type ProviderComponentClassDef struct {
	// cloud provider name
	// +kubebuilder:validation:Required
	Provider string `json:"provider"`

	// cloud provider specific variables
	// +optional
	Args []string `json:"args,omitempty"`
}

type Volume struct {
	// The volume name, etc. data, log.
	// +kubebuilder:validation:Required
	Name string `json:"name"`

	// The size of the volume.
	// +kubebuilder:validation:Required
	Size resource.Quantity `json:"size"`

	// The StorageClass name of the volume.
	// +optional
	StorageClassName *string `json:"storageCLassName,omitempty"`
}

// ComponentClassDefinitionStatus defines the observed state of ComponentClassDefinition
type ComponentClassDefinitionStatus struct {
	// observedGeneration is the most recent generation observed for this
	// ComponentClassDefinition. It corresponds to the ComponentClassDefinition's generation, which is
	// updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`

	// classes is the list of classes that have been observed for this ComponentClassDefinition
	Classes []ComponentClassInstance `json:"classes,omitempty"`
}

type ComponentClassInstance struct {
	ComponentClass `json:",inline"`

	// resourceConstraintRef reference to the resource constraint object name.
	ResourceConstraintRef string `json:"resourceConstraintRef,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:resource:categories={kubeblocks},scope=Cluster,shortName=ccd

// ComponentClassDefinition is the Schema for the componentclassdefinitions API
type ComponentClassDefinition struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   ComponentClassDefinitionSpec   `json:"spec,omitempty"`
	Status ComponentClassDefinitionStatus `json:"status,omitempty"`
}

//+kubebuilder:object:root=true

// ComponentClassDefinitionList contains a list of ComponentClassDefinition
type ComponentClassDefinitionList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ComponentClassDefinition `json:"items"`
}

func init() {
	SchemeBuilder.Register(&ComponentClassDefinition{}, &ComponentClassDefinitionList{})
}

func (r *ComponentClass) ToResourceRequirements() corev1.ResourceRequirements {
	requests := corev1.ResourceList{
		corev1.ResourceCPU:    r.CPU,
		corev1.ResourceMemory: r.Memory,
	}
	return corev1.ResourceRequirements{Requests: requests, Limits: requests}
}
