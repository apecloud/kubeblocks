/*
Copyright ApeCloud, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
	"fmt"
	"sort"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// BackupSpec defines the desired state of Backup
type BackupSpec struct {
	// which backupPolicy to perform this backup
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Pattern:=`^[a-z0-9]([a-z0-9\.\-]*[a-z0-9])?$`
	BackupPolicyName string `json:"backupPolicyName"`

	// Backup Type. full or incremental or snapshot. if unset, default is full.
	// +kubebuilder:default=full
	BackupType BackupType `json:"backupType"`

	// if backupType is incremental, parentBackupName is required.
	// +optional
	ParentBackupName string `json:"parentBackupName,omitempty"`
}

// BackupStatus defines the observed state of Backup
type BackupStatus struct {
	// +optional
	Phase BackupPhase `json:"phase,omitempty"`

	// record parentBackupName if backupType is incremental.
	// +optional
	ParentBackupName string `json:"parentBackupName,omitempty"`

	// The date and time when the Backup is eligible for garbage collection.
	// 'null' means the Backup is NOT be cleaned except delete manual.
	// +optional
	Expiration *metav1.Time `json:"expiration,omitempty"`

	// Date/time when the backup started being processed.
	// +optional
	StartTimestamp *metav1.Time `json:"startTimestamp,omitempty"`

	// Date/time when the backup finished being processed.
	// +optional
	CompletionTimestamp *metav1.Time `json:"completionTimestamp,omitempty"`

	// The duration time of backup execution.
	// When converted to a string, the form is "1h2m0.5s".
	// +optional
	Duration *metav1.Duration `json:"duration,omitempty"`

	// backup total size
	// string with capacity units in the form of "1Gi", "1Mi", "1Ki".
	// +optional
	TotalSize string `json:"totalSize,omitempty"`

	// the reason if backup failed.
	// +optional
	FailureReason string `json:"failureReason,omitempty"`

	// remoteVolume saves the backup data.
	// +optional
	PersistentVolumeClaimName string `json:"persistentVolumeClaimName,omitempty"`

	// backupToolName referenced backup tool name.
	// +optional
	BackupToolName string `json:"backupToolName,omitempty"`

	// manifests determines the backup metadata info
	// +optional
	Manifests *ManifestsStatus `json:"manifests,omitempty"`
}

type ManifestsStatus struct {
	// backupLog records startTime and stopTime of data logging
	// +optional
	BackupLog *BackupLogStatus `json:"backupLog,omitempty"`

	// target records the target cluster metadata string, which are in JSON format.
	// +optional
	Target string `json:"target,omitempty"`

	// snapshot records the volume snapshot metadata
	// +optional
	Snapshot *BackupSnapshotStatus `json:"backupSnapshot,omitempty"`

	// backupTool records information about backup files generated by the backup tool.
	// +optional
	BackupTool *BackupToolManifestsStatus `json:"backupTool,omitempty"`

	// userContext stores some loosely structured and extensible information.
	// +optional
	UserContext map[string]string `json:"userContext,omitempty"`
}

type BackupLogStatus struct {
	// startTime record start time of data logging
	// +optional
	StartTime *metav1.Time `json:"startTime,omitempty"`

	// stopTime record start time of data logging
	// +optional
	StopTime *metav1.Time `json:"stopTime,omitempty"`
}

type BackupSnapshotStatus struct {
	// volumeSnapshotName record the volumeSnapshot name
	// +optional
	VolumeSnapshotName string `json:"volumeSnapshotName,omitempty"`

	// volumeSnapshotContentName specifies the name of a pre-existing VolumeSnapshotContent
	// object representing an existing volume snapshot.
	// This field should be set if the snapshot already exists and only needs a representation in Kubernetes.
	// This field is immutable.
	// +optional
	VolumeSnapshotContentName string `json:"volumeSnapshotContentName,omitempty"`
}

type BackupToolManifestsStatus struct {
	// filePath records the file path of backup.
	// +optional
	FilePath string `json:"filePath,omitempty"`

	// backup upload total size
	// string with capacity units in the form of "1Gi", "1Mi", "1Ki".
	// +optional
	UploadTotalSize string `json:"uploadTotalSize,omitempty"`

	// checksum of backup file, generated by md5 or sha1 or sha256
	// +optional
	CheckSum string `json:"checkSum,omitempty"`

	// backup check point, for incremental backup.
	// +optional
	CheckPoint string `json:"CheckPoint,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:resource:categories={kubeblocks},scope=Namespaced
// +kubebuilder:printcolumn:name="TYPE",type=string,JSONPath=`.spec.backupType`
// +kubebuilder:printcolumn:name="STATUS",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="TOTAL-SIZE",type=string,JSONPath=`.status.totalSize`
// +kubebuilder:printcolumn:name="DURATION",type=string,JSONPath=`.status.duration`
// +kubebuilder:printcolumn:name="CREATE-TIME",type=string,JSONPath=".metadata.creationTimestamp"
// +kubebuilder:printcolumn:name="COMPLETION-TIME",type=string,JSONPath=`.status.completionTimestamp`

// Backup is the Schema for the backups API (defined by User)
type Backup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   BackupSpec   `json:"spec,omitempty"`
	Status BackupStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// BackupList contains a list of Backup
type BackupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Backup `json:"items"`
}

func init() {
	SchemeBuilder.Register(&Backup{}, &BackupList{})
}

// Validate validates the BackupSpec and returns an error if invalid.
func (r *BackupSpec) Validate(backupPolicy *BackupPolicy) error {
	notSupportedMessage := "backupPolicy: %s not supports %s backup in backupPolicy"
	switch r.BackupType {
	case BackupTypeSnapshot:
		if backupPolicy.Spec.Snapshot == nil {
			return fmt.Errorf(notSupportedMessage, r.BackupPolicyName, BackupTypeSnapshot)
		}
	case BackupTypeFull:
		if backupPolicy.Spec.Full == nil {
			return fmt.Errorf(notSupportedMessage, r.BackupPolicyName, BackupTypeFull)
		}
	case BackupTypeIncremental:
		if backupPolicy.Spec.Incremental == nil {
			return fmt.Errorf(notSupportedMessage, r.BackupPolicyName, BackupTypeIncremental)
		}
	}
	return nil
}

// GetRecoverableTimeRange return the recoverable time range array
func GetRecoverableTimeRange(backups []Backup) []BackupLogStatus {
	// filter backups with backupLog
	baseBackups := make([]Backup, 0)
	var incrementalBackup *Backup
	for _, b := range backups {
		if b.Status.Manifests == nil || b.Status.Manifests.BackupLog == nil ||
			b.Status.Manifests.BackupLog.StopTime == nil {
			continue
		}
		if b.Spec.BackupType == BackupTypeIncremental {
			incrementalBackup = &b
		} else if b.Spec.BackupType != BackupTypeIncremental && b.Status.Phase == BackupCompleted {
			baseBackups = append(baseBackups, b)
		}
	}
	if len(baseBackups) == 0 {
		return nil
	}
	sort.Slice(backups, func(i, j int) bool {
		if backups[i].Status.StartTimestamp == nil && backups[j].Status.StartTimestamp != nil {
			return false
		}
		if backups[i].Status.StartTimestamp != nil && backups[j].Status.StartTimestamp == nil {
			return true
		}
		if backups[i].Status.StartTimestamp.Equal(backups[j].Status.StartTimestamp) {
			return backups[i].Name < backups[j].Name
		}
		return backups[i].Status.StartTimestamp.Before(backups[j].Status.StartTimestamp)
	})
	result := make([]BackupLogStatus, 0)
	start, end := baseBackups[0].Status.Manifests.BackupLog.StopTime, baseBackups[0].Status.Manifests.BackupLog.StopTime
	if incrementalBackup != nil && start.Before(incrementalBackup.Status.Manifests.BackupLog.StopTime) {
		end = incrementalBackup.Status.Manifests.BackupLog.StopTime
	}
	return append(result, BackupLogStatus{StartTime: start, StopTime: end})
}
