## @section Common parameters
##

versionOverride:

## KubeBlocks container image settings
##
## @param image.registry KubeBlocks image registry
## @param image.repository KubeBlocks image repository
## @param image.pullPolicy KubeBlocks image pull policy
## @param image.tag KubeBlocks image tag (immutable tags are recommended)
## @param image.imagePullSecrets KubeBlocks image pull secrets
## @param image.tools.repository KubeBlocks tools image repository
image:
  registry: registry.cn-hangzhou.aliyuncs.com
  repository: apecloud/kubeblocks
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""
  imagePullSecrets: []
  tools:
    repository: apecloud/kubeblocks-tools

## @param separatedDeployment separated the KubeBlocks deployment into two deployments.
## This switch is used to isolate the apps controller and dataprotection controller
##
separatedDeployment: true

## @param replicaCount
##
replicaCount: 1

## @param nameOverride
##
nameOverride: ""

## @param fullnameOverride
##
fullnameOverride: ""


## KubeBlocks RBAC access priority setting
## 
## @param rbac.enabled is used to enable or disable KubeBlocks RBAC access priority. 
## By enabling this feature, KubeBlocks can ensure resource accessibility for the 
## cluster's pods, which are required to efficiently manage the cluster. By default,
## it is set to true. When RBAC access priority is enabled, KubeBlocks will have 
## the following permissions:
##   groups=core,resources=serviceaccounts,verbs=get;list;watch;create;update;patch;delete
##   groups=core,resources=serviceaccounts/status,verbs=get;update;patch
##   groups=core,resources=serviceaccounts/finalizers,verbs=update
##
##   groups=rbac.authorization.k8s.io,resources=rolebindings,verbs=get;list;watch;create;update;patch;delete
##   groups=rbac.authorization.k8s.io,resources=rolebindings/status,verbs=get;update;patch
##   groups=rbac.authorization.k8s.io,resources=rolebindings/finalizers,verbs=update
##
## If it is set to false, then you will need to create the service account 
## named `cluster.ComponentSpec.ServiceAccountName` and the corresponding role binding 
## manually or through the cluster's Helm template, as shown in the example:
##   helm install mysql apecloud-mysql-cluster
rbac:
  enabled: true

## Deployment update strategy.
## Ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
##
## @param updateStrategy.rollingUpdate
## @param updateStrategy.type
updateStrategy:
  rollingUpdate:
    maxSurge: 1
    maxUnavailable: 40%
  type: RollingUpdate

## Change `hostNetwork` to `true` when you want the KubeBlocks's pod to share its host's network namespace.
## Useful for situations like when you end up dealing with a custom CNI over Amazon EKS.
## Update the `dnsPolicy` accordingly as well to suit the host network mode.
##
## @param hostNetwork
##
hostNetwork: false

## `dnsPolicy` determines the manner in which DNS resolution happens in the cluster.
## In case of `hostNetwork: true`, usually, the `dnsPolicy` is suitable to be `ClusterFirstWithHostNet`.
## For further reference: https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy.
##
## @param dnsPolicy
##
dnsPolicy: ClusterFirst

## Configure podDisruptionBudget spec settings
##
## @param podDisruptionBudget.minAvailable
## @param podDisruptionBudget.maxUnavailable
podDisruptionBudget:
  # Configures the minimum available pods for KubeBlocks disruptions.
  # Cannot be used if `maxUnavailable` is set.
  minAvailable: 1
  # Configures the maximum unavailable pods for KubeBlocks disruptions.
  # Cannot be used if `minAvailable` is set.
  maxUnavailable:


## Logger settings
##
## @param loggerSettings.developmentMode
## @param loggerSettings.encoder
## @param loggerSettings.level
## @param loggerSettings.timeEncoding
loggerSettings:
  # Development Mode defaults(encoder=consoleEncoder,logLevel=Debug,stackTraceLevel=Warn).
  # Production Mode defaults(encoder=jsonEncoder,logLevel=Info,stackTraceLevel=Error) (default false)
  developmentMode: false
  # log encoding (one of 'json' or 'console')
  encoder: console
  # log level, can be one of 'debug', 'info', 'error', or any integer value > 0
  # which corresponds to custom debug levels of increasing verbosity.
  level:
  # Zap time encoding (one of 'epoch', 'millis', 'nano', 'iso8601', 'rfc3339' or
  # 'rfc3339nano'). Defaults to 'iso8601'.
  timeEncoding: 'iso8601'

## ServiceAccount settings
##
## @param serviceAccount.create
## @param serviceAccount.annotations
## @param serviceAccount.name
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

## @param podAnnotations
##
podAnnotations: {}

## Security context settings
##
## @param securityContext.allowPrivilegeEscalation
## @param securityContext.capabilities
securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL

## Pod security context settings
##
## @param podSecurityContext.runAsNonRoot
## @param podSecurityContext.readOnlyRootFilesystem
## @param podSecurityContext.runAsUser
## @param podSecurityContext.fsGroup
## @param podSecurityContext.seccompProfile
podSecurityContext:
  runAsNonRoot: true
  # readOnlyRootFilesystem: true
  # runAsUser: 1000
  # fsGroup: 2000
  # TODO(user): For common cases that do not require escalating privileges
  # it is recommended to ensure that all your Pods/Containers are restrictive.
  # More info: https://kubernetes.io/docs/concepts/security/pod-security-standards/#restricted
  # Please uncomment the following code if your project does NOT have to work on old Kubernetes
  # versions < 1.19 or on vendors versions which do NOT support this field by default (i.e. Openshift < 4.11 ).
  # seccompProfile:
  #   type: RuntimeDefault

## Service settings
##
## @param service.type
## @param service.port
## @param service.nodePort
service:
  type: ClusterIP
  port: 9443
  # -- Service node port.
  # Only used if `service.type` is `NodePort`.
  nodePort:


## Metrics serviceMonitor parameters
## Enable this if you're using Prometheus Operator
##
## @param serviceMonitor.enabled
## @param serviceMonitor.port
## @param serviceMonitor.nodePort
serviceMonitor:
  enabled: false
  # metrics server will be exposed at this port.
  port: 8080
  # Only used if `service.type` is `NodePort`.
  nodePort:

## KubeBlocks pods deployment topologySpreadConstraints settings
##
## @param topologySpreadConstraints
topologySpreadConstraints: []


## Resource settings
##
## @param resources.limits
## @param resources.requests
resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # TODO(user): Configure the resources accordingly based on the project requirements.
  # More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  # limits:
  #   cpu: 500m
  #   memory: 128Mi
  # requests:
  #   cpu: 10m
  #   memory: 64Mi

## @param priorityClassName
##
priorityClassName:

## Autoscaling settings
##
## @param autoscaling.enabled
## @param autoscaling.minReplicas
## @param autoscaling.maxReplicas
## @param autoscaling.targetCPUUtilizationPercentage
## @param autoscaling.targetMemoryUtilizationPercentage
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80



## @param nodeSelector
##
nodeSelector: {}

## @param tolerations
##
tolerations:
  - key: kb-controller
    operator: Equal
    value: "true"
    effect: NoSchedule


## @param affinity
##
affinity:
  nodeAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        preference:
          matchExpressions:
            - key: kb-controller
              operator: In
              values:
                - "true"

## @param data plane settings
##
dataPlane:
  tolerations:
    - key: kb-data
      operator: Equal
      value: "true"
      effect: NoSchedule

  affinity:
    nodeAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          preference:
            matchExpressions:
              - key: kb-data
                operator: In
                values:
                  - "true"

## AdmissionWebhooks settings
##
## @param admissionWebhooks.enabled
## @param admissionWebhooks.createSelfSignedCert
## @param admissionWebhooks.ignoreReplicasCheck
admissionWebhooks:
  enabled: false
  createSelfSignedCert: true
  ignoreReplicasCheck: false

## Data protection settings
##
## @param dataProtection.enabled - set the dataProtection controllers for backup functions
## @param dataProtection.enableVolumeSnapshot - set this to true if cluster does have snapshot.storage.k8s.io API installed
## @param dataProtection.backupPVCName - set the default pvc to store the file for backup
## @param dataProtection.backupPVCInitCapacity - set the default pvc initCapacity if the pvc need to be created by backup controller
## @param dataProtection.backupPVCStorageClassName - set the default pvc storageClassName if the pvc need to be created by backup controller
## @param dataProtection.backupPVCCreatePolicy - set the default create policy of the pvc, optional values: IfNotPresent, Never
## @param dataProtection.backupPVConfigMapName - set the default configmap name which contains key "persistentVolume" and value of the persistentVolume struct.
## @param dataProtection.backupPVConfigMapNamespace - set the default configmap namespace of pv template.
dataProtection:
  enabled: true
  enableVolumeSnapshot: false
  backupPVCName: kb-backup-data
  backupPVCInitCapacity: ""
  backupPVCStorageClassName: ""
  backupPVCCreatePolicy: ""
  backupPVConfigMapName: ""
  backupPVConfigMapNamespace: ""

## Addon controller settings, this will require cluster-admin clusterrole.
##
## @param addonController.enabled
## @param addonController.jobTTL - is addon job time-to-live period, this value is time.Duration-parseable string.
  ## default value is "5m" if not provided.
## @param addonController.jobImagePullPolicy - addon install job image pull policy.
addonController:
  enabled: true
  jobTTL: "5m"
  jobImagePullPolicy: IfNotPresent


## @param keepAddons - keep Addon CR objects when delete this chart.
keepAddons: false

## @param addonChartLocationBase - KubeBlocks official addon's chart location base, to be released in an air-gapped environment.
addonChartLocationBase: https://jihulab.com/api/v4/projects/85949/packages/helm/stable/charts

## @param addonHelmInstallOptions - addon helm install options.
addonHelmInstallOptions:
  - "--atomic"
  - "--cleanup-on-fail"
  - "--wait"
  - "--insecure-skip-tls-verify"

## Prometheus Addon
##
prometheus:
  ## If false, prometheus sub-chart will not be installed
  ##
  enabled: false

  nameOverride: "playground"

  extraLabels:
    addons.extensions.kubeblocks.io: "true"

  # prometheus sub chart
  prometheus:
    alertmanager:

      ## ConfigMap override where fullname is {{.Release.Name}}-{{.Values.alertmanager.configMapOverrideName}}
      ## Defining configMapOverrideName will cause templates/alertmanager-configmap.yaml
      ## to NOT generate a ConfigMap resource
      ##
      configMapOverrideName: "alertmanager-config"

    server:
      global:
        ## How frequently to scrape targets by default
        ##
        scrape_interval: 15s
        ## How long until a scrape request times out
        ##
        scrape_timeout: 10s
        ## How frequently to evaluate rules
        ##
        evaluation_interval: 15s


      ## https://prometheus.io/docs/prometheus/latest/configuration/configuration/#remote_write
      ##
      remoteWrite: [ ]

      ## Prometheus' data retention period (default if not specified is 15 days)
      ##
      retention: "2d"

## loki settings for kubeblocks
loki:
  enabled: false
  singleBinary:
    replicas: 1
    tolerations:
      - key: kb-controller
        operator: Equal
        value: "true"
        effect: NoSchedule
  monitoring:
    lokiCanary:
      enabled: false
    selfMonitoring:
      enabled: false
      grafanaAgent:
        installOperator: false
    dashboards:
      enabled: false
    rules:
      enabled: false
    serviceMonitor:
      enabled: false
  test:
    enabled: false
  loki:
    auth_enabled: false
    commonConfig:
      replication_factor: 1
    storage:
      type: filesystem
    podSecurityContext:
      runAsNonRoot: false
      runAsUser: 0

grafana:
  ## If false, grafana sub-chart will not be installed
  ##
  enabled: false

  rbac:
    pspEnabled: false

  replicas: 1

  image:
    repository: registry.cn-hangzhou.aliyuncs.com/apecloud/grafana
    # Overrides the Grafana image tag whose default is the chart appVersion
    tag: 9.2.4

  ## Grafana server resource requests and limits
  ## Ref: http://kubernetes.io/docs/user-guide/compute-resources/
  ##
  resources: {}
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  ## Node tolerations for grafana scheduling to nodes with taints
  ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  ##
  tolerations:
    - key: kb-controller
      operator: Equal
      value: "true"
      effect: NoSchedule

  affinity:
    nodeAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          preference:
            matchExpressions:
              - key: kb-controller
                operator: In
                values:
                  - "true"

  ## Timezone for the default dashboards
  ## Other options are: browser or a specific timezone, i.e. Europe/Luxembourg
  ##
  defaultDashboardsTimezone:

  adminUser: admin
  adminPassword: kubeblocks

  sidecar:
    image:
      repository: registry.cn-hangzhou.aliyuncs.com/apecloud/k8s-sidecar
      tag: 1.19.2

    dashboards:
      enabled: true
      label: grafana_dashboard
      labelValue: "1"
      searchNamespace: ALL
      resource: configmap

    datasources:
      enabled: true
      label: grafana_datasource
      labelValue: "1"
      searchNamespace: ALL
      resource: configmap

      defaultDatasourceEnabled: true
      uid: prometheus

      skipReload: false
      initDatasources: true

  testFramework:
    enabled: false

  grafana.ini:
    # Basic auth is enabled by default and works with the builtin Grafana user password authentication system and LDAP authentication integration.
    auth.basic:
      enabled: false

    auth.anonymous:
      enabled: true
      # Hide the Grafana version text from the footer and help tooltip for unauthenticated users (default: false)
      hide_version: true

  ingress:
    enabled: false
    # For Kubernetes >= 1.18 you should specify the ingress-controller via the field ingressClassName
    # See https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/#specifying-the-class-of-an-ingress
    # ingressClassName: nginx
    # Values can be templated
    annotations: {}
      # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
    labels: {}
    path: /

    # pathType is only for k8s >= 1.1=
    pathType: Prefix

    hosts:
      - chart-example.local
    ## Extra paths to prepend to every host configuration. This is useful when working with annotation based services.
    extraPaths: []
    # - path: /*
    #   backend:
    #     serviceName: ssl-redirect
    #     servicePort: use-annotation
    ## Or for k8s > 1.19
    # - path: /*
    #   pathType: Prefix
    #   backend:
    #     service:
    #       name: ssl-redirect
    #       port:
    #         name: use-annotation


    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local

  ## Expose the grafana service to be accessed from outside the cluster (LoadBalancer service).
  ## or access it from within the cluster (ClusterIP service). Set the service type and the port to serve it.
  ## ref: http://kubernetes.io/docs/user-guide/services/
  ##
  service:
    enabled: true
    type: ClusterIP
    port: 80
    targetPort: 3000
    # targetPort: 4181 To be used with a proxy extraContainer
    ## Service annotations. Can be templated.
    annotations: {}
    labels: {}
    portName: service
    # Adds the appProtocol field to the service. This allows to work with istio protocol selection. Ex: "http" or "tcp"
    appProtocol: ""


### snapshot-controller settings
### ref: https://artifacthub.io/packages/helm/piraeus-charts/snapshot-controller#configuration
###
snapshot-controller:
  ## @param snapshot-controller.enabled -- Enable snapshot-controller chart.
  ##
  enabled: true
  ## @param snapshot-controller.replicaCount -- Number of replicas to deploy.
  ##
  replicaCount: 1
  ## snapshot-controller image setting, easy access for CN users.
  ## @param snapshot-controller.image.repository -- Repository to pull the image from.
  ##
  image:
    repository: registry.cn-hangzhou.aliyuncs.com/apecloud/snapshot-controller
    tag: v6.2.1

  tolerations:
    - key: kb-controller
      operator: Equal
      value: "true"
      effect: NoSchedule

  volumeSnapshotClasses:
    - name: default-vsc
      driver: hostpath.csi.k8s.io
      deletionPolicy: Delete

  affinity:
    nodeAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          preference:
            matchExpressions:
              - key: kb-controller
                operator: In
                values:
                  - "true"

kubeblocks-csi-driver:
  enabled: false


cloudProvider:
  ## cloudProvider secret settings
  ## @param cloudProvider.accessKey -- S3 Access Key.
  ## @param cloudProvider.secretKey -- S3 Secret Key.
  ## @param cloudProvider.region -- S3 region.
  ## @param cloudProvider.cloud -- cloud name: [aws,aliyun].
  ## @param cloudProvider.bucket -- S3 Bucket.
  accessKey: ""
  secretKey: ""
  region: ""
  name: ""
  bucket: ""

## csi-s3 settings
## ref: https://artifacthub.io/packages/helm/cloudve/csi-s3#configuration
##
csi-s3:
  ## @param backupRepo.enabled -- Enable csi-s3 chart.
  ##
  enabled: false

alertmanager-webhook-adaptor:
  ## Linkage with prometheus.enabled
  ##
  # enabled: false

  ## Webhook-Adaptor container image
  ##
  image:
    registry: registry.cn-hangzhou.aliyuncs.com

  affinity:
    nodeAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          preference:
            matchExpressions:
              - key: kb-controller
                operator: In
                values:
                  - "true"

  ## ConfigMap override where fullname is {{.Release.Name}}-{{.Values.configMapOverrideName}}
  ##
  configMapOverrideName: "config"

  ## Webhook-Adaptor ConfigMap Entries
  configFiles:
    config.yaml: { }

csi-hostpath-driver:
  ## @param csi-hostpath-driver.enabled -- Enable csi-hostpath-driver chart.
  ##
  enabled: false
  ## csi-hostpath-driver storageClass setting
  ## @param csi-hostpath-driver.storageClass.create -- Specifies whether the storage class should be created.
  ## @param csi-hostpath-driver.storageClass.default -- Specifies whether the storage class should be default after created.
  ##
  storageClass:
    create: true
    default: true

aws-load-balancer-controller:
  clusterName: ""
  enabled: false
  replicaCount: 1
  tolerations:
  - key: kb-controller
    operator: Equal
    value: "true"
    effect: NoSchedule
  serviceAccount:
    create: true
    name: kubeblocks-service-account-aws-load-balancer-controller
  affinity:
    nodeAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        preference:
          matchExpressions:
          - key: kb-controller
            operator: In
            values:
            - "true"

## k8s cluster feature gates, ref: https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/
enabledAlphaFeatureGates:
  ## @param enabledAlphaFeatureGates.recoverVolumeExpansionFailure -- Specifies whether feature gates RecoverVolumeExpansionFailure is enabled in k8s cluster.
  ##
  recoverVolumeExpansionFailure: false


agamotto:
  enabled: false
  image:
    registry: registry.cn-hangzhou.aliyuncs.com


## @section KubeBlocks default storageClass Parameters for cloud provider.
storageClass:
  mountOptions:
    - noatime
    - nobarrier
  provider:
    eks:
      volumeType: gp3
      fsType: xfs
    gke:
      volumeType: pd-balanced
      fsType: xfs
    aliyun:
      volumeType: cloud_essd
      fsType: xfs
    aks:
      volumeType: managed
      fsType: xfs
    tke:
      volumeType: CLOUD_SSD

external-dns:
  enabled: false
  domain: kubeblocks.io
  tolerations:
  - key: kb-controller
    operator: Equal
    value: "true"
    effect: NoSchedule
