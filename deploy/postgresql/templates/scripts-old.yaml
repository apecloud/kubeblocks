apiVersion: v1
kind: ConfigMap
metadata:
  name: postgresql-scripts-old
  labels:
    {{- include "postgresql.labels" . | nindent 4 }}
data:
  post_start.sh: |
    #!/bin/sh
    export PGPASSWORD=$POSTGRES_POSTGRES_PASSWORD
    echo "wait for the database to be accessible, trying to connect."
    while :
    do
        echo "start to connect postgres."
        psql -Upostgres -c "SELECT 1;" >/dev/null 2>&1
        if [ $? -eq 0 ]; then
            echo "postgres connect success, break now."
            if [ -f ${PGDATA}/recovery.signal ]; then
                psql -Upostgres -c "select pg_wal_replay_resume();"
            fi
            if [ -f ${PGDATA}/../init-scripts/restore.sh ]; then
               echo "restore.sh exist, remove it."
               rm -rf ${PGDATA}/../init-scripts/restore.sh
            fi
            break
        fi
        echo "postgres connect fail, sleep and try again."
        sleep 1
    done
    echo "create extension pg_stat_statements."
    psql -Upostgres -c "CREATE EXTENSION IF NOT EXISTS pg_stat_statements;" 2>&1
    if [ $? -eq 0 ];then
        echo "create extension pg_stat_statements success."
    else
        exit 1
    fi
  setup.sh: |
    #!/bin/bash
    set -o errexit
    set -o nounset

    am_i_root() {
        if [[ "$(id -u)" = "0" ]]; then
            true
        else
            false
        fi
        echo "am_i_root finish"
    }
    ########################
    user_exists() {
        local user="${1:?user is missing}"
        id "$user" >/dev/null 2>&1
    }
    ########################
    group_exists() {
        local group="${1:?group is missing}"
        getent group "$group" >/dev/null 2>&1
    }
    ########################
    ensure_group_exists() {
        local group="${1:?group is missing}"
        local gid=""
        local is_system_user=false
        echo "exec group exist"
        # Validate arguments
        shift 1
        while [ "$#" -gt 0 ]; do
            case "$1" in
            -i | --gid)
                shift
                gid="${1:?missing gid}"
                ;;
            -s | --system)
                is_system_user=true
                ;;
            *)
                echo "Invalid command line flag $1" >&2
                return 1
                ;;
            esac
            shift
        done
        echo "group while done"
        if ! group_exists "$group"; then
            local -a args=("$group")
            if [[ -n "$gid" ]]; then
                if group_exists "$gid"; then
                    echo "The GID $gid is already in use." >&2
                    return 1
                fi
                args+=("--gid" "$gid")
            fi
            $is_system_user && args+=("--system")
            groupadd "${args[@]}" >/dev/null 2>&1
        fi
        echo "group exist done"
    }
    ########################
    ensure_user_exists() {
        local user="${1:?user is missing}"
        local uid=""
        local group=""
        local append_groups=""
        local home=""
        local is_system_user=false
        echo "exec user exists"
        # Validate arguments
        shift 1
        while [ "$#" -gt 0 ]; do
            case "$1" in
            -i | --uid)
                shift
                uid="${1:?missing uid}"
                ;;
            -g | --group)
                shift
                group="${1:?missing group}"
                ;;
            -a | --append-groups)
                shift
                append_groups="${1:?missing append_groups}"
                ;;
            -h | --home)
                shift
                home="${1:?missing home directory}"
                ;;
            -s | --system)
                is_system_user=true
                ;;
            *)
                echo "Invalid command line flag $1" >&2
                return 1
                ;;
            esac
            shift
        done
        echo "while user done"
        if ! user_exists "$user"; then
            local -a user_args=("-N" "$user")
            if [[ -n "$uid" ]]; then
                if user_exists "$uid"; then
                    echo "The UID $uid is already in use."
                    return 1
                fi
                user_args+=("--uid" "$uid")
            else
                $is_system_user && user_args+=("--system")
            fi
            useradd "${user_args[@]}" >/dev/null 2>&1
        fi
        echo "user exist done"
        if [[ -n "$group" ]]; then
            local -a group_args=("$group")
            $is_system_user && group_args+=("--system")
            ensure_group_exists "${group_args[@]}"
            usermod -g "$group" "$user" >/dev/null 2>&1
        fi
        echo "group1 exist done"
        if [[ -n "$append_groups" ]]; then
            local -a groups
            read -ra groups <<<"$(tr ',;' ' ' <<<"$append_groups")"
            for group in "${groups[@]}"; do
                ensure_group_exists "$group"
                usermod -aG "$group" "$user" >/dev/null 2>&1
            done
        fi
        echo "group2 exist done"
        if [[ -n "$home" ]]; then
            mkdir -p "$home"
            usermod -d "$home" "$user" >/dev/null 2>&1
            configure_permissions_ownership "$home" -d "775" -f "664" -u "$user" -g "$group"
        fi
        echo "user exist finish"
    }
    ########################
    configure_permissions_ownership() {
        local -r paths="${1:?paths is missing}"
        local dir_mode=""
        local file_mode=""
        local user=""
        local group=""

        # Validate arguments
        shift 1
        while [ "$#" -gt 0 ]; do
            case "$1" in
            -f | --file-mode)
                shift
                file_mode="${1:?missing mode for files}"
                ;;
            -d | --dir-mode)
                shift
                dir_mode="${1:?missing mode for directories}"
                ;;
            -u | --user)
                shift
                user="${1:?missing user}"
                ;;
            -g | --group)
                shift
                group="${1:?missing group}"
                ;;
            *)
                echo "Invalid command line flag $1" >&2
                return 1
                ;;
            esac
            shift
        done

        read -r -a filepaths <<<"$paths"
        for p in "${filepaths[@]}"; do
            if [[ -e "$p" ]]; then
                find -L "$p" -printf ""
                if [[ -n $dir_mode ]]; then
                    find -L "$p" -type d ! -perm "$dir_mode" -print0 | xargs -r -0 chmod "$dir_mode"
                fi
                if [[ -n $file_mode ]]; then
                    find -L "$p" -type f ! -perm "$file_mode" -print0 | xargs -r -0 chmod "$file_mode"
                fi
                if [[ -n $user ]] && [[ -n $group ]]; then
                    find -L "$p" -print0 | xargs -r -0 chown "${user}:${group}"
                elif [[ -n $user ]] && [[ -z $group ]]; then
                    find -L "$p" -print0 | xargs -r -0 chown "${user}"
                elif [[ -z $user ]] && [[ -n $group ]]; then
                    find -L "$p" -print0 | xargs -r -0 chgrp "${group}"
                fi
            else
                echo "$p does not exist"
            fi
        done
    }
    ########################
    postgresql_slave_init_db() {
        local -r check_args=("-U" "$POSTGRESQL_REPLICATION_USER" "-h" "$POSTGRESQL_MASTER_HOST" "-p" "$POSTGRESQL_MASTER_PORT_NUMBER" "-d" "postgres")
        local check_cmd=()
        if am_i_root; then
            check_cmd=("gosu" "$POSTGRESQL_DAEMON_USER")
        fi
        check_cmd+=("$POSTGRESQL_BIN_DIR"/pg_isready)
        local ready_counter=$POSTGRESQL_INIT_MAX_TIMEOUT

        while ! PGPASSWORD=$POSTGRESQL_REPLICATION_PASSWORD "${check_cmd[@]}" "${check_args[@]}"; do
            sleep 1
            ready_counter=$((ready_counter - 1))
            if ((ready_counter <= 0)); then
                echo "PostgreSQL master is not ready after $POSTGRESQL_INIT_MAX_TIMEOUT seconds"
                exit 1
            fi

        done
        local -r backup_args=("-D" "$POSTGRESQL_DATA_DIR" "-U" "$POSTGRESQL_REPLICATION_USER" "-h" "$POSTGRESQL_MASTER_HOST" "-p" "$POSTGRESQL_MASTER_PORT_NUMBER" "-X" "stream" "-w" "-v" "-P")
        local backup_cmd=()
        if am_i_root; then
            backup_cmd+=("gosu" "$POSTGRESQL_DAEMON_USER")
        fi
        backup_cmd+=("$POSTGRESQL_BIN_DIR"/pg_basebackup)
        local replication_counter=$POSTGRESQL_INIT_MAX_TIMEOUT
        while ! PGPASSWORD=$POSTGRESQL_REPLICATION_PASSWORD "${backup_cmd[@]}" "${backup_args[@]}"; do
            sleep 1
            replication_counter=$((replication_counter - 1))
            if ((replication_counter <= 0)); then
                echo "Slave replication failed after trying for $POSTGRESQL_INIT_MAX_TIMEOUT seconds"
                exit 1
            fi
        done
    }
    ########################
    export POSTGRESQL_INIT_MAX_TIMEOUT="${POSTGRESQL_INIT_MAX_TIMEOUT:-60}"
    export POSTGRESQL_DAEMON_USER="postgres"
    export POSTGRESQL_DAEMON_GROUP="postgres"
    export POSTGRESQL_BIN_DIR="/usr/local/bin"
    export POSTGRESQL_DATA_DIR="/postgresql/data"

    KB_PRIMARY_POD_NAME_PREFIX="${KB_PRIMARY_POD_NAME%%\.*}"
    # debug
    echo "KB_PRIMARY_POD_NAME=$KB_PRIMARY_POD_NAME"
    echo "KB_PRIMARY_POD_NAME_PREFIX=$KB_PRIMARY_POD_NAME_PREFIX"
    echo "KB_POD_NAME=$KB_POD_NAME"
    if [ "$KB_PRIMARY_POD_NAME_PREFIX" != "$KB_POD_NAME" ]; then
      export POSTGRES_REPLICATION_MODE=slave
      # TODO: use replicator instead
      export POSTGRESQL_REPLICATION_USER=$POSTGRES_USER
      export POSTGRESQL_REPLICATION_PASSWORD=$POSTGRES_PASSWORD
      export POSTGRES_CLUSTER_APP_NAME=my-application
      export POSTGRESQL_MASTER_HOST=$KB_PRIMARY_POD_NAME
      export POSTGRESQL_MASTER_PORT_NUMBER="5432"
      # add permission to daemon user
      chmod a+w "$POSTGRESQL_VOLUME_DIR"
      echo "chmod finish"
      # Ensure 'daemon' user exists when running as 'root'
      am_i_root && ensure_user_exists "$POSTGRESQL_DAEMON_USER" --group "$POSTGRESQL_DAEMON_GROUP"
      echo "am_i_root finish"
      if [ ! -d ${PGDATA} ]; then
         # pg_basebackup
         echo "exec slave init"
         postgresql_slave_init_db
         echo "slave init finish"
      fi
    else
      cp /scripts/post_start.sh /docker-entrypoint-initdb.d
    fi
    if [ -f ${PGDATA}/../init-scripts/restore.sh ]; then
        # add recovery.signal/standby.signal to trigger recovery
        cp ${PGDATA}/../init-scripts/restore.sh /docker-entrypoint-preinitdb.d
    fi
    docker-entrypoint.sh --config-file=/postgresql/conf/postgresql.conf --hba_file=postgresql/conf/pg_hba.conf &
    while true
    do
      sleep 60
    done